{"ast":null,"code":"\"use strict\";\n/**\r\n * utility functions for preparing `startAnchor` and `endAnchor` to accept the diffrent types that can be passed.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getShortestLine = exports.prepareAnchorLines = void 0;\n\nconst index_1 = require(\"./index\");\n\nconst getAnchorsDefaultOffsets = (width, height) => {\n  return {\n    middle: {\n      rightness: width * 0.5,\n      bottomness: height * 0.5\n    },\n    left: {\n      rightness: 0,\n      bottomness: height * 0.5\n    },\n    right: {\n      rightness: width,\n      bottomness: height * 0.5\n    },\n    top: {\n      rightness: width * 0.5,\n      bottomness: 0\n    },\n    bottom: {\n      rightness: width * 0.5,\n      bottomness: height\n    }\n  };\n};\n\nexports.prepareAnchorLines = (anchor, anchorPos) => {\n  let defsOffsets = getAnchorsDefaultOffsets(anchorPos.right - anchorPos.x, anchorPos.bottom - anchorPos.y); // convert given anchors to array if not array already\n\n  let anchorChoice = Array.isArray(anchor) ? anchor : [anchor];\n  if (anchorChoice.length == 0) anchorChoice = [\"auto\"]; //now map each item in the array to relevant object\n\n  let anchorChoiceMapped = anchorChoice.map(anchorChoice => {\n    if (index_1.typeOf(anchorChoice) === \"string\") {\n      anchorChoice = anchorChoice;\n      return {\n        position: anchorChoice,\n        offset: {\n          rightness: 0,\n          bottomness: 0\n        }\n      };\n    } else if (index_1.typeOf(anchorChoice) === \"object\") {\n      if (!anchorChoice.offset) anchorChoice.offset = {\n        rightness: 0,\n        bottomness: 0\n      };\n      if (!anchorChoice.offset.bottomness) anchorChoice.offset.bottomness = 0;\n      if (!anchorChoice.offset.rightness) anchorChoice.offset.rightness = 0;\n      anchorChoice = anchorChoice;\n      return anchorChoice;\n    }\n  }); //now build the object that represents the users possibilities for different anchors\n\n  let anchorPossibilities = [];\n\n  if (anchorChoiceMapped.map(a => a.position).includes(\"auto\")) {\n    let autoAnchor = anchorChoiceMapped.find(a => a.position === \"auto\");\n    [\"left\", \"right\", \"top\", \"bottom\"].forEach(anchor => {\n      let offset = defsOffsets[anchor];\n      offset.rightness += autoAnchor.offset.rightness;\n      offset.bottomness += autoAnchor.offset.bottomness;\n      anchorPossibilities.push({\n        position: anchor,\n        offset\n      });\n    });\n  } else {\n    anchorChoiceMapped.forEach(customAnchor => {\n      let offset = defsOffsets[customAnchor.position];\n      offset.rightness += customAnchor.offset.rightness;\n      offset.bottomness += customAnchor.offset.bottomness;\n      anchorPossibilities.push({\n        position: customAnchor.position,\n        offset\n      });\n    });\n  } // now prepare this list of anchors to object expected by the `getShortestLine` function\n\n\n  return anchorPossibilities.map(pos => ({\n    x: anchorPos.x + pos.offset.rightness,\n    y: anchorPos.y + pos.offset.bottomness,\n    anchorPosition: pos.position\n  }));\n};\n\nconst dist = (p1, p2) => {\n  //length of line\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nexports.getShortestLine = (sPoints, ePoints) => {\n  // closes tPair Of Points which feet to the specified anchors\n  let minDist = Infinity,\n      d = Infinity;\n  let closestPair;\n  sPoints.forEach(sp => {\n    ePoints.forEach(ep => {\n      d = dist(sp, ep);\n\n      if (d < minDist) {\n        minDist = d;\n        closestPair = {\n          startPointObj: sp,\n          endPointObj: ep\n        };\n      }\n    });\n  });\n  return closestPair;\n};","map":null,"metadata":{},"sourceType":"script"}