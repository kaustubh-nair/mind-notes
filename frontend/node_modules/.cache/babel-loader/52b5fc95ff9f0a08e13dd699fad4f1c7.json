{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/kau/projects/acad/spe/mind-note-frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\n\nconst lodash_pick_1 = __importDefault(require(\"lodash.pick\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst prop_types_1 = __importDefault(require(\"prop-types\"));\n\nconst buzzier_1 = require(\"./utils/buzzier\");\n\nconst anchors_1 = require(\"./utils/anchors\");\n\nconst Xarrow = props => {\n  let startAnchor = props.startAnchor,\n      endAnchor = props.endAnchor,\n      label = props.label,\n      color = props.color,\n      lineColor = props.lineColor,\n      headColor = props.headColor,\n      strokeWidth = props.strokeWidth,\n      showHead = props.showHead,\n      headSize = props.headSize,\n      showTail = props.showTail,\n      tailColor = props.tailColor,\n      tailSize = props.tailSize,\n      path = props.path,\n      curveness = props.curveness,\n      dashness = props.dashness,\n      passProps = props.passProps,\n      SVGcanvasProps = props.SVGcanvasProps,\n      arrowBodyProps = props.arrowBodyProps,\n      arrowHeadProps = props.arrowHeadProps,\n      arrowTailProps = props.arrowTailProps,\n      divContainerProps = props.divContainerProps,\n      SVGcanvasStyle = props.SVGcanvasStyle,\n      divContainerStyle = props.divContainerStyle,\n      _extendSVGcanvas = props._extendSVGcanvas,\n      _debug = props._debug,\n      _cpx1Offset = props._cpx1Offset,\n      _cpy1Offset = props._cpy1Offset,\n      _cpx2Offset = props._cpx2Offset,\n      _cpy2Offset = props._cpy2Offset,\n      extraProps = __rest(props, [\"startAnchor\", \"endAnchor\", \"label\", \"color\", \"lineColor\", \"headColor\", \"strokeWidth\", \"showHead\", \"headSize\", \"showTail\", \"tailColor\", \"tailSize\", \"path\", \"curveness\", \"dashness\", \"passProps\", \"SVGcanvasProps\", \"arrowBodyProps\", \"arrowHeadProps\", \"arrowTailProps\", \"divContainerProps\", \"SVGcanvasStyle\", \"divContainerStyle\", \"_extendSVGcanvas\", \"_debug\", \"_cpx1Offset\", \"_cpy1Offset\", \"_cpx2Offset\", \"_cpy2Offset\"]);\n\n  const selfRef = react_1.useRef(null);\n\n  const _react_1$useState = react_1.useState({\n    start: null,\n    end: null\n  }),\n        _react_1$useState2 = _slicedToArray(_react_1$useState, 2),\n        anchorsRefs = _react_1$useState2[0],\n        setAnchorsRefs = _react_1$useState2[1];\n\n  const _react_1$useState3 = react_1.useState(null),\n        _react_1$useState4 = _slicedToArray(_react_1$useState3, 2),\n        prevPosState = _react_1$useState4[0],\n        setPrevPosState = _react_1$useState4[1];\n\n  const _react_1$useState5 = react_1.useState(null),\n        _react_1$useState6 = _slicedToArray(_react_1$useState5, 2),\n        prevProps = _react_1$useState6[0],\n        setPrevProps = _react_1$useState6[1];\n  /**\r\n   * determine if an update is needed and update if so.\r\n   * update is needed if one of the connected elements position was changed since last render, or if the ref to one\r\n   * of the elements has changed(it points to a different element).\r\n   */\n\n\n  const updateIfNeeded = () => {\n    // check if anchors refs changed\n    const start = utils_1.getElementByPropGiven(props.start);\n    const end = utils_1.getElementByPropGiven(props.end); // in case one of the elements does not mounted skip any update\n\n    if (start == null || end == null) return; // if anchors changed re-set them\n\n    if (!lodash_isequal_1.default(anchorsRefs, {\n      start,\n      end\n    })) {\n      initAnchorsRefs();\n    } else if (!lodash_isequal_1.default(props, prevProps)) {\n      //first check if any properties changed\n      if (prevProps) {\n        initProps();\n        let posState = getAnchorsPos();\n        setPrevPosState(posState);\n        updatePosition(posState);\n      }\n    } else {\n      //if the properties did not changed - update position if needed\n      let posState = getAnchorsPos();\n\n      if (!lodash_isequal_1.default(prevPosState, posState)) {\n        setPrevPosState(posState);\n        updatePosition(posState);\n      }\n    }\n  };\n\n  const initAnchorsRefs = () => {\n    const start = utils_1.getElementByPropGiven(props.start);\n    const end = utils_1.getElementByPropGiven(props.end);\n    setAnchorsRefs({\n      start,\n      end\n    });\n  };\n\n  const initProps = () => {\n    setPrevProps(props);\n  };\n\n  const monitorDOMchanges = () => {\n    window.addEventListener(\"resize\", updateIfNeeded);\n  };\n\n  const cleanMonitorDOMchanges = () => {\n    window.removeEventListener(\"resize\", updateIfNeeded);\n  };\n\n  react_1.useEffect(() => {\n    // console.log(\"xarrow mounted\");\n    initProps();\n    initAnchorsRefs();\n    monitorDOMchanges();\n    return () => {\n      cleanMonitorDOMchanges();\n    };\n  }, []);\n  react_1.useLayoutEffect(() => {\n    // console.log(\"xarrow rendered!\");\n    updateIfNeeded();\n  });\n\n  const _react_1$useState7 = react_1.useState({\n    //initial state\n    cx0: 0,\n    cy0: 0,\n    cw: 0,\n    ch: 0,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    dx: 0,\n    dy: 0,\n    absDx: 0,\n    absDy: 0,\n    cpx1: 0,\n    cpy1: 0,\n    cpx2: 0,\n    cpy2: 0,\n    headOrient: 0,\n    tailOrient: 0,\n    labelStartPos: {\n      x: 0,\n      y: 0\n    },\n    labelMiddlePos: {\n      x: 0,\n      y: 0\n    },\n    labelEndPos: {\n      x: 0,\n      y: 0\n    },\n    arrowEnd: {\n      x: 0,\n      y: 0\n    },\n    arrowHeadOffset: {\n      x: 0,\n      y: 0\n    },\n    arrowTailOffset: {\n      x: 0,\n      y: 0\n    },\n    headOffset: 0,\n    excRight: 0,\n    excLeft: 0,\n    excUp: 0,\n    excDown: 0\n  }),\n        _react_1$useState8 = _slicedToArray(_react_1$useState7, 2),\n        st = _react_1$useState8[0],\n        setSt = _react_1$useState8[1];\n\n  headSize = Number(headSize);\n  strokeWidth = Number(strokeWidth);\n  headColor = headColor ? headColor : color;\n  tailColor = tailColor ? tailColor : color;\n  lineColor = lineColor ? lineColor : color;\n  let dashStroke = 0,\n      dashNone = 0,\n      animationSpeed,\n      animationDirection = 1;\n\n  if (dashness) {\n    if (typeof dashness === \"object\") {\n      dashStroke = dashness.strokeLen ? Number(dashness.strokeLen) : Number(strokeWidth) * 2;\n      dashNone = dashness.strokeLen ? Number(dashness.nonStrokeLen) : Number(strokeWidth);\n      animationSpeed = dashness.animation ? Number(dashness.animation) : null;\n    } else if (typeof dashness === \"boolean\") {\n      dashStroke = Number(strokeWidth) * 2;\n      dashNone = Number(strokeWidth);\n      animationSpeed = null;\n    }\n  }\n\n  let dashoffset = dashStroke + dashNone;\n\n  if (animationSpeed < 0) {\n    animationSpeed *= -1;\n    animationDirection = -1;\n  }\n\n  let labelStart = null,\n      labelMiddle = null,\n      labelEnd = null;\n\n  if (label) {\n    if (typeof label === \"string\" || \"type\" in label) labelMiddle = label;else if ([\"start\", \"middle\", \"end\"].some(key => key in label)) {\n      label = label;\n      var _label = label;\n      labelStart = _label.start;\n      labelMiddle = _label.middle;\n      labelEnd = _label.end;\n    }\n  }\n\n  const getSelfPos = () => {\n    let _selfRef$current$getB = selfRef.current.getBoundingClientRect(),\n        xarrowElemX = _selfRef$current$getB.left,\n        xarrowElemY = _selfRef$current$getB.top;\n\n    let xarrowStyle = getComputedStyle(selfRef.current);\n    let xarrowStyleLeft = Number(xarrowStyle.left.slice(0, -2));\n    let xarrowStyleTop = Number(xarrowStyle.top.slice(0, -2));\n    return {\n      x: xarrowElemX - xarrowStyleLeft,\n      y: xarrowElemY - xarrowStyleTop\n    };\n  };\n\n  const getAnchorsPos = () => {\n    let s = anchorsRefs.start.getBoundingClientRect();\n    let e = anchorsRefs.end.getBoundingClientRect();\n    return {\n      start: {\n        x: s.left,\n        y: s.top,\n        right: s.right,\n        bottom: s.bottom\n      },\n      end: {\n        x: e.left,\n        y: e.top,\n        right: e.right,\n        bottom: e.bottom\n      }\n    };\n  };\n  /**\r\n   * The Main logic of path calculation for the arrow.\r\n   * calculate new path and adjust canvas based on given properties.\r\n   * */\n\n\n  const updatePosition = positions => {\n    let sPos = positions.start;\n    let ePos = positions.end;\n    let headOrient = 0;\n    let tailOrient = 0; // convert startAnchor and endAnchor to list of objects represents allowed anchors.\n\n    let startPointsObj = anchors_1.prepareAnchorLines(startAnchor, sPos);\n    let endPointsObj = anchors_1.prepareAnchorLines(endAnchor, ePos); // choose the smallest path for 2 points from these possibilities.\n\n    let _anchors_1$getShortes = anchors_1.getShortestLine(startPointsObj, endPointsObj),\n        startPointObj = _anchors_1$getShortes.startPointObj,\n        endPointObj = _anchors_1$getShortes.endPointObj;\n\n    let startAnchorPosition = startPointObj.anchorPosition,\n        endAnchorPosition = endPointObj.anchorPosition;\n    let startPoint = lodash_pick_1.default(startPointObj, [\"x\", \"y\"]),\n        endPoint = lodash_pick_1.default(endPointObj, [\"x\", \"y\"]);\n    let xarrowElemPos = getSelfPos();\n    let cx0 = Math.min(startPoint.x, endPoint.x) - xarrowElemPos.x;\n    let cy0 = Math.min(startPoint.y, endPoint.y) - xarrowElemPos.y;\n    let dx = endPoint.x - startPoint.x;\n    let dy = endPoint.y - startPoint.y;\n    let absDx = Math.abs(endPoint.x - startPoint.x);\n    let absDy = Math.abs(endPoint.y - startPoint.y);\n    let xSign = dx > 0 ? 1 : -1;\n    let ySign = dy > 0 ? 1 : -1;\n    let headOffset = headSize * 3 / 4 * strokeWidth;\n    let tailOffset = tailSize * 3 / 4 * strokeWidth;\n    let cu = Number(curveness);\n\n    if (path === \"straight\") {\n      cu = 0;\n      path = \"smooth\";\n    }\n\n    let biggerSide = headSize > tailSize ? headSize : tailSize;\n    let calc = strokeWidth + strokeWidth * biggerSide / 2;\n    let excRight = calc;\n    let excLeft = calc;\n    let excUp = calc;\n    let excDown = calc;\n    excLeft += Number(_extendSVGcanvas);\n    excRight += Number(_extendSVGcanvas);\n    excUp += Number(_extendSVGcanvas);\n    excDown += Number(_extendSVGcanvas); ////////////////////////////////////\n    // arrow point to point calculations\n\n    let x1 = 0,\n        x2 = absDx,\n        y1 = 0,\n        y2 = absDy;\n\n    if (dx < 0) {\n      var _ref = [x2, x1];\n      x1 = _ref[0];\n      x2 = _ref[1];\n    }\n\n    if (dy < 0) {\n      var _ref2 = [y2, y1];\n      y1 = _ref2[0];\n      y2 = _ref2[1];\n    } ////////////////////////////////////\n    // arrow curviness and arrowhead placement calculations\n\n\n    let xHeadOffset = 0;\n    let yHeadOffset = 0;\n    let xTailOffset = 0;\n    let yTailOffset = 0;\n\n    if (cu === 0) {\n      // in case of straight path\n      let headAngel = Math.atan(absDy / absDx);\n\n      if (showHead) {\n        x2 -= headOffset * xSign * Math.cos(headAngel);\n        y2 -= headOffset * ySign * Math.sin(headAngel); // cpx2 -= headOffset * xSign * Math.cos(headAngel);\n        // cpy2 -= headOffset * ySign * Math.sin(headAngel);\n\n        headAngel *= ySign;\n        if (xSign < 0) headAngel = (Math.PI - headAngel * xSign) * xSign;\n        xHeadOffset = Math.cos(headAngel) * headOffset / 3 - Math.sin(headAngel) * (headSize * strokeWidth) / 2;\n        yHeadOffset = Math.cos(headAngel) * (headSize * strokeWidth) / 2 + Math.sin(headAngel) * headOffset / 3;\n        headOrient = headAngel * 180 / Math.PI;\n      }\n\n      let tailAngel = Math.atan(absDy / absDx);\n\n      if (showTail) {\n        x1 += tailOffset * xSign * Math.cos(tailAngel);\n        y1 += tailOffset * ySign * Math.sin(tailAngel); // cpx2 -= headOffset * xSign * Math.cos(headAngel);\n        // cpy2 -= headOffset * ySign * Math.sin(headAngel);\n\n        tailAngel *= -ySign;\n        if (xSign > 0) tailAngel = (Math.PI - tailAngel * xSign) * xSign;\n        xTailOffset = Math.cos(tailAngel) * tailOffset / 3 - Math.sin(tailAngel) * (tailSize * strokeWidth) / 2;\n        yTailOffset = Math.cos(tailAngel) * (tailSize * strokeWidth) / 2 + Math.sin(tailAngel) * tailOffset / 3;\n        tailOrient = tailAngel * 180 / Math.PI;\n      } //todo: add tail support\n\n    } else {\n      // in case of smooth path\n      if (endAnchorPosition === \"middle\") {\n        // in case a middle anchor is chosen for endAnchor choose from which side to attach to the middle of the element\n        if (absDx > absDy) {\n          endAnchorPosition = xSign ? \"left\" : \"right\";\n        } else {\n          endAnchorPosition = ySign ? \"top\" : \"bottom\";\n        }\n      }\n\n      if (showHead) {\n        if ([\"left\", \"right\"].includes(endAnchorPosition)) {\n          x2 -= headOffset * xSign; // cpx2 -= headOffset * xSign * 2;\n          // cpx1 += headOffset * xSign;\n\n          xHeadOffset = headOffset * xSign / 3;\n          yHeadOffset = headSize * strokeWidth * xSign / 2;\n\n          if (endAnchorPosition === \"left\") {\n            headOrient = 0;\n            if (xSign < 0) headOrient += 180;\n          } else {\n            headOrient = 180;\n            if (xSign > 0) headOrient += 180;\n          }\n        } else if ([\"top\", \"bottom\"].includes(endAnchorPosition)) {\n          yHeadOffset = headOffset * ySign / 3;\n          xHeadOffset = headSize * strokeWidth * -ySign / 2;\n          y2 -= headOffset * ySign; // cpy1 += headOffset * ySign;\n          // cpy2 -= headOffset * ySign;\n\n          if (endAnchorPosition === \"top\") {\n            headOrient = 270;\n            if (ySign > 0) headOrient += 180;\n          } else {\n            headOrient = 90;\n            if (ySign < 0) headOrient += 180;\n          }\n        }\n      }\n    }\n\n    if (showTail && cu !== 0) {\n      if ([\"left\", \"right\"].includes(startAnchorPosition)) {\n        x1 += tailOffset * xSign;\n        xTailOffset = -(tailOffset * xSign) / 3;\n        yTailOffset = -(tailSize * strokeWidth * xSign) / 2;\n\n        if (startAnchorPosition === \"left\") {\n          tailOrient = 180;\n          if (xSign < 0) tailOrient += 180;\n        } else {\n          tailOrient = 0;\n          if (xSign > 0) tailOrient += 180;\n        }\n      } else if ([\"top\", \"bottom\"].includes(startAnchorPosition)) {\n        yTailOffset = -(tailOffset * ySign) / 3;\n        xTailOffset = -(tailSize * strokeWidth * -ySign) / 2;\n        y1 += tailOffset * ySign; // cpy1 += tailOffset * ySign;\n        // cpy2 -= tailOffset * ySign;\n\n        if (startAnchorPosition === \"top\") {\n          tailOrient = 90;\n          if (ySign > 0) tailOrient += 180;\n        } else {\n          tailOrient = 270;\n          if (ySign < 0) tailOrient += 180;\n        }\n      }\n    } // if (endAnchorPosition == startAnchorPosition) headOrient += 180;\n\n\n    let arrowHeadOffset = {\n      x: xHeadOffset,\n      y: yHeadOffset\n    };\n    let arrowTailOffset = {\n      x: xTailOffset,\n      y: yTailOffset\n    };\n    let cpx1 = x1,\n        cpy1 = y1,\n        cpx2 = x2,\n        cpy2 = y2;\n    let curvesPossibilities = {};\n    if (path === \"smooth\") curvesPossibilities = {\n      hh: () => {\n        //horizontal - from right to left or the opposite\n        cpx1 += absDx * cu * xSign;\n        cpx2 -= absDx * cu * xSign; // if (absDx < 2 * headOffset) {\n        //   cpx1 += headOffset * xSign - absDx / 2;\n        //   cpx2 -= headOffset * xSign * 2 - absDx;\n        // }\n        // cpx1 += headOffset * 2 * xSign;\n        // cpx2 -= headOffset * 2 * xSign;\n      },\n      vv: () => {\n        //vertical - from top to bottom or opposite\n        cpy1 += absDy * cu * ySign;\n        cpy2 -= absDy * cu * ySign; // cpy1 += headOffset * 2 * ySign;\n        // cpy2 -= headOffset * 2 * ySign;\n      },\n      hv: () => {\n        // start horizontally then vertically\n        // from v side to h side\n        cpx1 += absDx * cu * xSign;\n        cpy2 -= absDy * cu * ySign;\n      },\n      vh: () => {\n        // start vertically then horizontally\n        // from h side to v side\n        cpy1 += absDy * cu * ySign;\n        cpx2 -= absDx * cu * xSign;\n      }\n    };else if (path === \"grid\") {\n      curvesPossibilities = {\n        hh: () => {\n          // cpx1 += (absDx * 0.5 - headOffset / 2) * xSign;\n          // cpx2 -= (absDx * 0.5 - headOffset / 2) * xSign;\n          cpx1 += absDx * 0.5 * xSign;\n          cpx2 -= absDx * 0.5 * xSign;\n\n          if (showHead) {\n            cpx1 -= headOffset / 2 * xSign;\n            cpx2 += headOffset / 2 * xSign;\n          }\n\n          if (showTail) {\n            cpx1 -= tailOffset / 2 * xSign;\n            cpx2 += tailOffset / 2 * xSign;\n          }\n        },\n        vv: () => {\n          // cpy1 += (absDy * 0.5 - headOffset / 2) * ySign;\n          // cpy2 -= (absDy * 0.5 - headOffset / 2) * ySign;\n          cpy1 += absDy * 0.5 * ySign;\n          cpy2 -= absDy * 0.5 * ySign;\n\n          if (showHead) {\n            cpy1 -= headOffset / 2 * ySign;\n            cpy2 += headOffset / 2 * ySign;\n          }\n\n          if (showTail) {\n            cpy1 -= tailOffset / 2 * ySign;\n            cpy2 += tailOffset / 2 * ySign;\n          }\n        },\n        hv: () => {\n          cpx1 = x2;\n        },\n        vh: () => {\n          cpy1 = y2;\n        }\n      };\n    } // smart select best curve for the current anchors\n\n    let selectedCurviness = \"\";\n    if ([\"left\", \"right\"].includes(startAnchorPosition)) selectedCurviness += \"h\";else if ([\"bottom\", \"top\"].includes(startAnchorPosition)) selectedCurviness += \"v\";else if (startAnchorPosition === \"middle\") selectedCurviness += \"m\";\n    if ([\"left\", \"right\"].includes(endAnchorPosition)) selectedCurviness += \"h\";else if ([\"bottom\", \"top\"].includes(endAnchorPosition)) selectedCurviness += \"v\";else if (endAnchorPosition === \"middle\") selectedCurviness += \"m\";\n    if (absDx > absDy) selectedCurviness = selectedCurviness.replace(/m/g, \"h\");else selectedCurviness = selectedCurviness.replace(/m/g, \"v\");\n    curvesPossibilities[selectedCurviness]();\n    cpx1 += _cpx1Offset;\n    cpy1 += _cpy1Offset;\n    cpx2 += _cpx2Offset;\n    cpy2 += _cpy2Offset; ////////////////////////////////////\n    // canvas smart size adjustments\n\n    const _buzzier_1$buzzierMin = buzzier_1.buzzierMinSols(x1, cpx1, cpx2, x2),\n          _buzzier_1$buzzierMin2 = _slicedToArray(_buzzier_1$buzzierMin, 2),\n          xSol1 = _buzzier_1$buzzierMin2[0],\n          xSol2 = _buzzier_1$buzzierMin2[1];\n\n    const _buzzier_1$buzzierMin3 = buzzier_1.buzzierMinSols(y1, cpy1, cpy2, y2),\n          _buzzier_1$buzzierMin4 = _slicedToArray(_buzzier_1$buzzierMin3, 2),\n          ySol1 = _buzzier_1$buzzierMin4[0],\n          ySol2 = _buzzier_1$buzzierMin4[1];\n\n    if (xSol1 < 0) excLeft += -xSol1;\n    if (xSol2 > absDx) excRight += xSol2 - absDx;\n    if (ySol1 < 0) excUp += -ySol1;\n    if (ySol2 > absDy) excDown += ySol2 - absDy;\n\n    if (path === \"grid\") {\n      excLeft += calc;\n      excRight += calc;\n      excUp += calc;\n      excDown += calc;\n    }\n\n    x1 += excLeft;\n    x2 += excLeft;\n    y1 += excUp;\n    y2 += excUp;\n    cpx1 += excLeft;\n    cpx2 += excLeft;\n    cpy1 += excUp;\n    cpy2 += excUp;\n    const cw = absDx + excLeft + excRight,\n          ch = absDy + excUp + excDown;\n    cx0 -= excLeft;\n    cy0 -= excUp; //labels\n\n    const bzx = buzzier_1.bzFunction(x1, cpx1, cpx2, x2);\n    const bzy = buzzier_1.bzFunction(y1, cpy1, cpy2, y2);\n    const labelStartPos = {\n      x: bzx(0.01),\n      y: bzy(0.01)\n    };\n    const labelMiddlePos = {\n      x: bzx(0.5),\n      y: bzy(0.5)\n    };\n    const labelEndPos = {\n      x: bzx(0.99),\n      y: bzy(0.99)\n    };\n    const arrowEnd = {\n      x: bzx(1),\n      y: bzy(1)\n    };\n    setSt({\n      cx0,\n      cy0,\n      x1,\n      x2,\n      y1,\n      y2,\n      cw,\n      ch,\n      cpx1,\n      cpy1,\n      cpx2,\n      cpy2,\n      dx,\n      dy,\n      absDx,\n      absDy,\n      headOrient,\n      tailOrient,\n      labelStartPos,\n      labelMiddlePos,\n      labelEndPos,\n      arrowEnd,\n      excLeft,\n      excRight,\n      excUp,\n      excDown,\n      headOffset,\n      arrowHeadOffset,\n      arrowTailOffset\n    });\n  };\n\n  const fHeadSize = headSize * strokeWidth; //factored head size\n\n  const fTailSize = tailSize * strokeWidth; //factored head size\n\n  const xOffsetHead = st.x2 - st.arrowHeadOffset.x;\n  const yOffsetHead = st.y2 - st.arrowHeadOffset.y;\n  const xOffsetTail = st.x1 - st.arrowTailOffset.x;\n  const yOffsetTail = st.y1 - st.arrowTailOffset.y; // console.log(\"x1,x2,tailOrient\\n:\", st.x1, st.x2, st.tailOrient);\n\n  let arrowPath = \"M \".concat(st.x1, \" \").concat(st.y1, \" C \").concat(st.cpx1, \" \").concat(st.cpy1, \", \").concat(st.cpx2, \" \").concat(st.cpy2, \", \").concat(st.x2, \" \").concat(st.y2, \" \");\n  if (path === \"straight\") arrowPath = \"M \".concat(st.x1, \" \").concat(st.y1, \"  \").concat(st.x2, \" \").concat(st.y2);\n  if (path === \"grid\") arrowPath = \"M \".concat(st.x1, \" \").concat(st.y1, \" L  \").concat(st.cpx1, \" \").concat(st.cpy1, \" L \").concat(st.cpx2, \" \").concat(st.cpy2, \" L  \").concat(st.x2, \" \").concat(st.y2);\n  return react_1.default.createElement(\"div\", Object.assign({}, divContainerProps, {\n    style: Object.assign({\n      position: \"absolute\"\n    }, divContainerStyle)\n  }, extraProps), react_1.default.createElement(\"svg\", Object.assign({\n    ref: selfRef,\n    width: st.cw,\n    height: st.ch,\n    style: Object.assign({\n      position: \"absolute\",\n      left: st.cx0,\n      top: st.cy0,\n      pointerEvents: \"none\",\n      border: _debug ? \"1px dashed yellow\" : null\n    }, SVGcanvasStyle),\n    overflow: \"auto\"\n  }, SVGcanvasProps), _debug ? react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"circle\", {\n    r: \"5\",\n    cx: st.cpx1,\n    cy: st.cpy1,\n    fill: \"green\"\n  }), react_1.default.createElement(\"circle\", {\n    r: \"5\",\n    cx: st.cpx2,\n    cy: st.cpy2,\n    fill: \"blue\"\n  }), react_1.default.createElement(\"rect\", {\n    x: st.excLeft,\n    y: st.excUp,\n    width: st.absDx,\n    height: st.absDy,\n    fill: \"none\",\n    stroke: \"pink\",\n    strokeWidth: \"2px\"\n  })) : null, showTail ? react_1.default.createElement(\"path\", Object.assign({\n    d: \"M 0 0 L \".concat(fTailSize, \" \").concat(fTailSize / 2, \" L 0 \").concat(fTailSize, \" L \").concat(fTailSize / 4, \" \").concat(fTailSize / 2, \" z\"),\n    fill: tailColor,\n    pointerEvents: \"all\",\n    transform: \"translate(\".concat(xOffsetTail, \",\").concat(yOffsetTail, \") rotate(\").concat(st.tailOrient, \")\")\n  }, passProps, arrowTailProps)) : null, react_1.default.createElement(\"path\", Object.assign({\n    d: arrowPath,\n    stroke: lineColor,\n    strokeDasharray: \"\".concat(dashStroke, \" \").concat(dashNone),\n    strokeWidth: strokeWidth,\n    fill: \"transparent\",\n    pointerEvents: \"visibleStroke\"\n  }, passProps, arrowBodyProps), animationSpeed ? react_1.default.createElement(\"animate\", {\n    attributeName: \"stroke-dashoffset\",\n    values: \"\".concat(dashoffset * animationDirection, \";0\"),\n    dur: \"\".concat(1 / animationSpeed, \"s\"),\n    repeatCount: \"indefinite\"\n  }) : null), showHead ? react_1.default.createElement(\"path\", Object.assign({\n    d: \"M 0 0 L \".concat(fHeadSize, \" \").concat(fHeadSize / 2, \" L 0 \").concat(fHeadSize, \" L \").concat(fHeadSize / 4, \" \").concat(fHeadSize / 2, \" z\"),\n    fill: headColor,\n    pointerEvents: \"all\",\n    transform: \"translate(\".concat(xOffsetHead, \",\").concat(yOffsetHead, \") rotate(\").concat(st.headOrient, \")\")\n  }, passProps, arrowHeadProps)) : null), labelStart ? react_1.default.createElement(\"div\", {\n    style: {\n      transform: st.dx < 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\n      width: \"max-content\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelStartPos.x,\n      top: st.cy0 + st.labelStartPos.y - strokeWidth - 5\n    }\n  }, labelStart) : null, labelMiddle ? react_1.default.createElement(\"div\", {\n    style: {\n      display: \"table\",\n      width: \"max-content\",\n      transform: \"translate(-50% , -50%)\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelMiddlePos.x,\n      top: st.cy0 + st.labelMiddlePos.y\n    }\n  }, labelMiddle) : null, labelEnd ? react_1.default.createElement(\"div\", {\n    style: {\n      transform: st.dx > 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\n      width: \"max-content\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelEndPos.x,\n      top: st.cy0 + st.labelEndPos.y + strokeWidth + 5\n    }\n  }, labelEnd) : null);\n}; //////////////////////////////\n// propTypes\n\n\nconst pAnchorPositionType = prop_types_1.default.oneOf([\"middle\", \"left\", \"right\", \"top\", \"bottom\", \"auto\"]);\nconst pAnchorCustomPositionType = prop_types_1.default.exact({\n  position: pAnchorPositionType.isRequired,\n  offset: prop_types_1.default.shape({\n    rightness: prop_types_1.default.number,\n    bottomness: prop_types_1.default.number\n  }).isRequired\n});\n\nconst _pAnchorType = prop_types_1.default.oneOfType([pAnchorPositionType, pAnchorCustomPositionType]);\n\nconst pAnchorType = prop_types_1.default.oneOfType([_pAnchorType, prop_types_1.default.arrayOf(_pAnchorType)]);\nconst pRefType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.exact({\n  current: prop_types_1.default.instanceOf(Element)\n})]);\n\nconst _pLabelType = prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.string]);\n\nconst pLabelsType = prop_types_1.default.exact({\n  start: _pLabelType,\n  middle: _pLabelType,\n  end: _pLabelType\n});\nXarrow.propTypes = {\n  start: pRefType.isRequired,\n  end: pRefType.isRequired,\n  startAnchor: pAnchorType,\n  endAnchor: pAnchorType,\n  label: prop_types_1.default.oneOfType([_pLabelType, pLabelsType]),\n  color: prop_types_1.default.string,\n  lineColor: prop_types_1.default.string,\n  showHead: prop_types_1.default.bool,\n  headColor: prop_types_1.default.string,\n  headSize: prop_types_1.default.number,\n  tailSize: prop_types_1.default.number,\n  tailColor: prop_types_1.default.string,\n  strokeWidth: prop_types_1.default.number,\n  showTail: prop_types_1.default.bool,\n  path: prop_types_1.default.oneOf([\"smooth\", \"grid\", \"straight\"]),\n  curveness: prop_types_1.default.number,\n  dashness: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.object]),\n  passProps: prop_types_1.default.object,\n  arrowBodyProps: prop_types_1.default.object,\n  arrowHeadProps: prop_types_1.default.object,\n  arrowTailProps: prop_types_1.default.object,\n  SVGcanvasProps: prop_types_1.default.object,\n  divContainerProps: prop_types_1.default.object,\n  _extendSVGcanvas: prop_types_1.default.number,\n  _debug: prop_types_1.default.bool,\n  _cpx1Offset: prop_types_1.default.number,\n  _cpy1Offset: prop_types_1.default.number,\n  _cpx2Offset: prop_types_1.default.number,\n  _cpy2Offset: prop_types_1.default.number\n};\nXarrow.defaultProps = {\n  startAnchor: \"auto\",\n  endAnchor: \"auto\",\n  label: null,\n  color: \"CornflowerBlue\",\n  lineColor: null,\n  headColor: null,\n  tailColor: null,\n  strokeWidth: 4,\n  showHead: true,\n  headSize: 6,\n  showTail: false,\n  tailSize: 6,\n  path: \"smooth\",\n  curveness: 0.8,\n  dashness: false,\n  passProps: {},\n  arrowBodyProps: {},\n  arrowHeadProps: {},\n  arrowTailProps: {},\n  SVGcanvasProps: {},\n  divContainerProps: {},\n  _extendSVGcanvas: 0,\n  _debug: false,\n  _cpx1Offset: 0,\n  _cpy1Offset: 0,\n  _cpx2Offset: 0,\n  _cpy2Offset: 0\n};\nexports.default = Xarrow;","map":null,"metadata":{},"sourceType":"script"}